{"Name":"Firebase - Cloud Messaging","Id":3325,"Alias":"firebase-messaging","Description":"Firebase - Cloud Messaging\n==========================\n\nUsing FCM, you can notify a client app that new email or other data is available to sync. You can send notification messages to drive user reengagement and retention. For use cases such as instant messaging, a message can transfer a payload of up to 4KB to a client app.\n\n\n### Key capabilities\n\n**Send notification messages or data messages**\tSend notification messages that are displayed to your user. Or send data messages and determine completely what happens in your application code. \n\n**See Message types.** Versatile message targeting\tDistribute messages to your client app in any of three ways — to single devices, to groups of devices, or to devices subscribed to topics.\n\n**Send messages from client apps** Send acknowledgments, chats, and other messages from devices back to your server over FCM’s reliable and battery-efficient connection channel.\n\n\n### How does it work?\n\nAn FCM implementation includes an app server that interacts with FCM via HTTP or XMPP protocol, and a client app. You can compose and send messages using the app server or the Notifications console.\n\nFirebase Notifications is built on Firebase Cloud Messaging and shares the same FCM SDK for client development. For testing or for sending marketing or engagement messages with powerful built-in targeting and analytics, you can use Notifications. For deployments with more complex messaging requirements, FCM is the right choice.\n\n","Version":"42.1001.0.0","Summary":"Cross-platform messaging solution that lets you reliably deliver messages at no cost.","QuickStart":"Get Started with Firebase Cloud Messaging for Android\n\n\nConfiguring Firebase\n--------------------\n\n1. Create a Firebase project in the [Firebase Console][1], if you don\u0027t already have one setup.  If you have an existing Google project associated with your mobile app, you can use the **Import Google Project** option.  Otherwise, use the **Create New Project** option.\n\n2. Click **Add Firebase to your Android app**.  \n\n  a. Enter your app\u0027s ***Package Name***\n  \n  b. Enter the SHA-1 Hash for your signing certificate.  If you don\u0027t know how to find this, [check out this guide][2]\n\n3. Click **Add App** and download the ***google-services.json*** file generated for you.\n\n4. Add the ***google-services.json*** file to your Xamarin.Android project.\n\n5. Set the *Build Action* for your ***google-services.json*** file to ***GoogleServicesJson***.  \n\nThe build process will take the api keys and values from your ***google-services.json*** and translate them into the correct resource string key/value pairs in your app.\n\n\n\n\n\n\n\n## Editing your AndroidManifest.xml\n\nCurrently, you will need to manually add the broadcast receiver declarations to your app\u0027s `AndroidManifest.xml` file.  You should add these declarations inside of your `\u003capplication ..\u003e\u003c/application\u003e` element:\n\n```xml\n\u003c!-- START Manual Firebase Additions --\u003e\n\u003creceiver\n  android:name=\"com.google.firebase.iid.FirebaseInstanceIdInternalReceiver\"\n  android:exported=\"false\" /\u003e\n\n\u003creceiver\n  android:name=\"com.google.firebase.iid.FirebaseInstanceIdReceiver\"\n  android:exported=\"true\"\n  android:permission=\"com.google.android.c2dm.permission.SEND\" \u003e\n\t\u003cintent-filter\u003e\n\t\t\u003caction android:name=\"com.google.android.c2dm.intent.RECEIVE\" /\u003e\n\t\t\u003caction android:name=\"com.google.android.c2dm.intent.REGISTRATION\" /\u003e\n\t\t\u003ccategory android:name=\"${applicationId}\" /\u003e\n\t\u003c/intent-filter\u003e\n\u003c/receiver\u003e\n\u003c!-- END Manual Firebase Additions --\u003e\n```\n\n\n## Create your Service\n\nIf you want to do any messaging handling beyond receiving notifications on apps in the background, such as receiving notifications in foregrounded apps, receiving data payloads, or sending upstream messages.\n\nThe service should extend `FirebaseMessagingService`, and declare the same intent filter as in the example below:\n\n```csharp\n[Service]\n[IntentFilter (new [] { \"com.google.firebase.MESSAGING_EVENT\" })]\npublic class MyFirebaseMessagingService : FirebaseMessagingService\n{\n    public override void OnMessageReceived (RemoteMessage message)\n    {\n        // TODO(developer): Handle FCM messages here.\n        // If the application is in the foreground handle both data and notification messages here.\n        // Also if you intend on generating your own notifications as a result of a received FCM\n        // message, here is where that should be initiated. See sendNotification method below.\n        Android.Util.Log.Debug (TAG, \"From: \" + message.From);\n        Android.Util.Log.Debug (TAG, \"Notification Message Body: \" + message.GetNotification ().Body);\n    }\n}\n```\n\nYou will also need a service that subclasses `FirebaseInstanceIdService` to handle the creation, rotation, and updating of registration tokens.  These tokens are required for sending notifications to specific devices, or adding devices to device groups:\n\n```csharp\n[Service]\n[IntentFilter (new [] { \"com.google.firebase.INSTANCE_ID_EVENT\" })]\npublic class MyFirebaseIIDService : FirebaseInstanceIdService\n{\n    /**\n     * Called if InstanceID token is updated. This may occur if the security of\n     * the previous token had been compromised. Note that this is called when the InstanceID token\n     * is initially generated so this is where you would retrieve the token.\n     */\n    public override void OnTokenRefresh ()\n    {\n        // Get updated InstanceID token.\n        var refreshedToken = FirebaseInstanceId.Instance.Token;\n        \n        // TODO: Implement this method to send any registration to your app\u0027s servers.\n    }\n}\n```\n\nIf FCM is critical to the Android app\u0027s function, be sure to set the minimum SDK Version to 8 or higher.  This ensures that the Android app cannot be installed in an environment in which it could not run properly.\n\n \n### Check for Google Play Services APK\n\nApps that rely on the Play Services SDK should always check the device for a compatible Google Play services APK before accessing Google Play services features.  It is recommended to do this in two places: in the main activity\u0027s `OnCreate ()` method, and in its `OnResume ()` method.\n\n\nThe check in `OnCreate ()` ensures that the app can\u0027t be used without a successful check. The check in `OnResume ()` ensures that if the user returns to the running app through some other means, such as through the back button, the check is still performed. If the device doesn\u0027t have a compatible Google Play services APK, your app can call `GooglePlayServicesUtil.GetErrorDialog ()` to allow users to download the APK from the Google Play Store or enable it in the device\u0027s system settings.\n\n## Access the device registration token\n\nOn initial startup of your app, the FCM SDK generates a registration token for the client app instance. If you want to target single devices or create device groups, you\u0027ll need to access this token by extending `FirebaseInstanceIdService` as in the previous example.\n\nThis section describes how to retrieve the token and how to monitor changes to the token. Because the token could be rotated after initial startup, you are strongly recommended to retrieve the latest updated registration token.\n\nThe registration token may change when:\n\n - The app deletes Instance ID\n - The app is restored on a new device\n - The user uninstalls/reinstall the app\n - The user clears app data.\n - Retrieve the current registration token\n\nWhen you need to retrieve the current token, call `FirebaseInstanceID.Instance.Token`. This property returns null if the token has not yet been generated.\n\n\n### Monitor token generation\n\nThe `OnTokenRefreshcallback` method fires whenever a new token is generated, so accessing `Token` in its context ensures that you are accessing a current, available registration token. Make sure you have added the service to your manifest, then call `Token` in the context of `OnTokenRefresh`, and log the value as shown:\n\n```csharp\npublic override void OnTokenRefresh ()\n{\n    // Get updated InstanceID token.\n    var refreshedToken = FirebaseInstanceId.Instance.Token;\n    Android.Util.Log.Debug (TAG, \"Refreshed token: \" + refreshedToken);\n\n    // If you want to send messages to this application instance or\n    // manage this apps subscriptions on the server side, send the\n    // Instance ID token to your app server.\n    sendRegistrationToServer(refreshedToken);\n}\n```\n\nAfter you\u0027ve obtained the token, you can send it to your app server and store it using your preferred method. \n\n\nSamples\n=======\n\nYou can find a Sample Application within each Firebase component.  The sample will demonstrate the necessary configuration and some basic API usages.\n\n\n\n\n\n\nLearn More\n==========\n\nYou can learn more about the various Firebase SDKs \u0026 APIs by visiting the official [Firebase][5] documentation\n\n\n\n\n[1]: https://console.developers.google.com/ \"Google Developers Console\"\n[2]: https://developer.xamarin.com/guides/android/deployment,_testing,_and_metrics/MD5_SHA1/ \"Finding your SHA-1 Fingerprints\"\n[3]: https://developers.google.com/android/ \"Google APIs for Android\"\n[4]: https://firebase.google.com/console/ \"Firebase Developer Console\"\n[5]: https://firebase.google.com/ \"Firebase\"\n","Hash":"5b944b8f9aea3d1181d4acbc72cf1d33","TargetPlatforms":["android"],"TrialHash":null}